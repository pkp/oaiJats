<?php

/**
 * @file OAIMetadataFormat_JATS.php
 *
 * Copyright (c) 2013-2025 Simon Fraser University
 * Copyright (c) 2003-2025 John Willinsky
 * Distributed under the GNU GPL v3. For full terms see the file LICENSE.
 *
 * @class OAIMetadataFormat_JATS
 * @see OAI
 *
 * @brief OAI metadata format class -- JATS
 */

namespace APP\plugins\oaiMetadataFormats\oaiJats;

use APP\core\Application;
use APP\facades\Repo;
use APP\issue\Issue;
use APP\issue\IssueAction;
use APP\journal\Journal;
use APP\oai\ojs\OAIDAO;
use APP\section\Section;
use APP\submission\Submission;
use DOMDocument;
use DOMNode;
use DOMXPath;
use PKP\db\DAORegistry;
use PKP\i18n\LocaleConversion;
use PKP\oai\OAIMetadataFormat;
use PKP\oai\OAIRecord;
use PKP\plugins\Hook;
use PKP\plugins\PluginRegistry;
use PKP\submission\Genre;
use PKP\submissionFile\SubmissionFile;

class OAIMetadataFormat_JATS extends OAIMetadataFormat
{
    /**
     * Identify a candidate JATS file to expose via OAI.
     */
    protected function findJats(OAIRecord $record): ?DOMDocument
    {
        $article = $record->getData('article'); /** @var Submission $article */
        $galleys = $record->getData('galleys'); /** @var iterable|Galley[] $galleys */

        $candidateFiles = [];

        $plugin = PluginRegistry::getPlugin('oaiMetadataFormats', 'OAIMetadataFormatPlugin_JATS');
        $forceJatsTemplate = $plugin->getSetting($article->getData('contextId'), 'forceJatsTemplate');

        // First, look for candidates in the galleys area (published content).
        if (!$forceJatsTemplate) {
            foreach ($galleys as $galley) {
                $galleyFile = Repo::submissionFile()->get((int) $galley->getData('submissionFileId'));
                if ($galleyFile && $this->isCandidateFile($galleyFile)) {
                    $candidateFiles[] = $galleyFile;
                }
            }

            // If no candidates were found, look in the layout area (unpublished content).
            if (empty($candidateFiles)) {
                $layoutFiles = Repo::submissionFile()->getCollector()
                    ->filterByFileStages([SubmissionFile::SUBMISSION_FILE_PRODUCTION_READY])
                    ->filterBySubmissionIds([$article->getId()])
                    ->getMany();

                foreach ($layoutFiles as $layoutFile) {
                    if ($this->isCandidateFile($layoutFile)) {
                        $candidateFiles[] = $layoutFile;
                    }
                }
            }
        }

        // Store uploaded file separately if exists
        $uploadedDoc = null;
        if (!empty($candidateFiles)) {
            if (count($candidateFiles) > 1) {
                error_log('WARNING: More than one JATS XML candidate documents were located for submission ' . $article->getId() . '.');
            }
            $candidateFile = array_shift($candidateFiles);
            $fileService = app()->get('file');
            $filepath = $fileService->get($candidateFile->getData('fileId'))->path;
            $uploadedDoc = new DOMDocument();
            $uploadedDoc->loadXML($fileService->fs->read($filepath));
        }

        // Always generate template JATS (source of truth for metadata)
        $templateDoc = null;
        Hook::call(
            'OAIMetadataFormat_JATS::findJats',
            [&$this, &$record, &$candidateFiles, &$templateDoc]
        );

        // If no template was generated, return null
        if (!$templateDoc) {
            return null;
        }

        // If we have an uploaded file, merge body/back content into template
        if ($uploadedDoc) {
            $templateDoc = $this->mergeJatsContent($templateDoc, $uploadedDoc);
        }

        return $templateDoc;
    }

    /**
     * Merge body and back content from uploaded JATS into template JATS.
     *
     * This preserves the front details (metadata) from the template while
     * using the body and back (article content) from the uploaded file.
     *
     * @param DOMDocument $templateDoc The JATS generated by JatsTemplate (metadata source)
     * @param DOMDocument $uploadedDoc The uploaded JATS file (content source)
     * @return DOMDocument The merged document
     */
    protected function mergeJatsContent(DOMDocument $templateDoc, DOMDocument $uploadedDoc): DOMDocument
    {
        $templateXpath = new DOMXPath($templateDoc);
        $uploadedXpath = new DOMXPath($uploadedDoc);

        // Get the article node from template
        $templateArticle = $templateXpath->query('//article')->item(0);
        if (!$templateArticle) {
            return $templateDoc;
        }

        // Transplant <body> from uploaded if it exists
        $uploadedBody = $uploadedXpath->query('//article/body')->item(0);
        if ($uploadedBody) {
            // Remove template's body if exists
            $templateBody = $templateXpath->query('//article/body')->item(0);
            if ($templateBody) {
                $templateArticle->removeChild($templateBody);
            }
            // Import and append uploaded body
            $importedBody = $templateDoc->importNode($uploadedBody, true);
            $templateArticle->appendChild($importedBody);
        }

        // Transplant <back> from uploaded if it exists
        $uploadedBack = $uploadedXpath->query('//article/back')->item(0);
        if ($uploadedBack) {
            // Remove template's back if exists
            $templateBack = $templateXpath->query('//article/back')->item(0);
            if ($templateBack) {
                $templateArticle->removeChild($templateBack);
            }
            // Import and append uploaded back
            $importedBack = $templateDoc->importNode($uploadedBack, true);
            $templateArticle->appendChild($importedBack);
        }

        return $templateDoc;
    }

    /**
     * @copydoc OAIMetadataFormat#toXml
     */
    public function toXml($record, $format = null)
    {
        $oaiDao = DAORegistry::getDAO('OAIDAO'); /** @var OAIDAO $oaiDao */
        $journal = $record->getData('journal'); /** @var Journal $journal */
        $article = $record->getData('article'); /** @var Submission $article */
        $section = $record->getData('section'); /** @var Section $section */
        $issue = $record->getData('issue'); /** @var Issue|null $issue */
        $allowedPrePublicationAccess = true;

        $request = Application::get()->getRequest();

        // Check access
        if ($issue) {
            $issueAction = new IssueAction();
            $subscriptionRequired = $issueAction->subscriptionRequired($issue, $journal);
            $isSubscribedDomain = $issueAction->subscribedDomain($request, $journal, $issue->getId(), $article->getId());
            $allowedPrePublicationAccess = $issueAction->allowedIssuePrePublicationAccess($journal, $request->getUser());
            if ($subscriptionRequired && (!$allowedPrePublicationAccess && !$isSubscribedDomain)) {
                $oaiDao->oai->error('cannotDisseminateFormat', 'Cannot disseminate format (unauthenticated access to JATS XML not allowed)');
                exit();
            }
        }

        $doc = $this->findJats($record);
        if (!$doc) {
            $oaiDao->oai->error('cannotDisseminateFormat', 'Cannot disseminate format (JATS XML not available)');
            exit();
        }

        $this->_mungeMetadata(
            $doc,
            $journal,
            $article,
            $section,
            $issue,
            $allowedPrePublicationAccess
        );

        return $doc->saveXml($doc->getElementsByTagName('article')->item(0));
    }

    /**
     * Add the child node to the parent node in the appropriate node order.
     *
     * @param DOMNode $parentNode The parent element.
     * @param DOMNode $childNode The child node.
     *
     * @return DOMNode The child node.
     */
    protected function _addChildInOrder(DOMNode $parentNode, DOMNode $childNode): DOMNode
    {
        $permittedElementOrders = [
            'front' => [
                'article-meta',
                'journal-meta'
            ],
            'article-meta' => [
                'article-id',
                'article-categories',
                'title-group',
                'contrib-group',
                'aff',
                'aff-alternatives',
                'x',
                'author-notes',
                'pub-date',
                'volume',
                'volume-id',
                'volume-series',
                'issue',
                'issue-id',
                'issue-title',
                'issue-sponsor',
                'issue-part',
                'isbn',
                'supplement',
                'fpage',
                'lpage',
                'page-range',
                'elocation-id',
                'email',
                'ext-link',
                'uri',
                'product',
                'supplementary-material',
                'history',
                'permissions',
                'self-uri',
                'related-article',
                'related-object',
                'abstract',
                'trans-abstract',
                'kwd-group',
                'funding-group',
                'conference',
                'counts',
                'custom-meta-group'
            ],
            'journal-meta' => [
                'journal-id',
                'journal-title-group',
                'contrib-group',
                'aff',
                'aff-alternatives',
                'issn',
                'issn-l',
                'isbn',
                'publisher',
                'notes',
                'self-uri',
                'custom-meta-group'
            ],
            'counts' => [
                'count',
                'fig-count',
                'table-count',
                'equation-count',
                'ref-count',
                'page-count',
                'word-count'
            ],
        ];

        assert(isset($permittedElementOrders[$parentNode->nodeName])); // We have an order list for the parent node
        $order = $permittedElementOrders[$parentNode->nodeName];
        $position = array_search($childNode->nodeName, $order);
        assert($position !== false); // The child node appears in the order list

        $followingElements = array_slice($order, $position);
        $followingElement = null;
        foreach ($parentNode->childNodes as $node) {
            if (in_array($node->nodeName, $followingElements)) {
                $followingElement = $node;
                break;
            }
        }

        return $parentNode->insertBefore($childNode, $followingElement);
    }

    /**
     * Apply OAI-specific transformations to the JATS XML document.
     *
     * This method applies only OAI-specific modifications to the JATS document
     * generated by JatsTemplate plugin. It does NOT regenerate content that
     * already exists in the base JATS document (e.g coming from JATS Template plugin)
     */
    protected function _mungeMetadata(
        DOMDocument $doc,
        Journal $journal,
        Submission $article,
        Section $section,
        ?Issue $issue = null,
        bool $allowedPrePublicationAccess = false
    ): void
    {
        $xpath = new DOMXPath($doc);
        $articleMetaNode = $xpath->query('//article/front/article-meta')->item(0);
        $publication = $article->getCurrentPublication();

        // Set OAI-specific article attributes
        $articleNode = $xpath->query('//article')->item(0);
        $articleNode->setAttribute('xml:lang', LocaleConversion::toBcp47($article->getData('locale')));
        $articleNode->setAttribute('dtd-version', '1.1');
        $articleNode->setAttribute('specific-use', 'eps-0.1');
        $articleNode->setAttribute('xmlns', 'https://jats.nlm.nih.gov/publishing/1.1/');

        // Set the issue publication date as collection date (OAI-specific requirement)
        // https://eruditps.docs.erudit.org/tagset/element-pub-date.html
        $issueYear = null;
        if ($issue && $issue->getShowYear()) {
            $issueYear = $issue->getYear();
        }

        if (!$issueYear && $issue && $issue->getDatePublished()) {
            $issueYear = date('Y', strtotime($issue->getDatePublished()));
        }

        if (!$issueYear && $publication->getData('datePublished')) {
            $issueYear = date('Y', strtotime($publication->getData('datePublished')));
        }

        if ($issueYear) {
            $match = $xpath->query("//article/front/article-meta/pub-date[@date-type='collection']");
            
            if ($match->length) {
                // An existing pub-date was found; empty and re-use.
                $dateNode = $match->item(0);
                while ($dateNode->hasChildNodes()) {
                    $dateNode->removeChild($dateNode->firstChild);
                }
            } else {
                // No pub-date was found; create a new one.
                $dateNode = $this->_addChildInOrder($articleMetaNode, $doc->createElement('pub-date'));
                $dateNode->setAttribute('date-type', 'collection');
            }

            $dateNode
                ->appendChild($doc->createElement('year'))
                ->appendChild($doc->createTextNode($issueYear));
        }

        // Remove author emails from public OAI export (OAI-specific requirement)
        if (!$allowedPrePublicationAccess) {
            $authorEmailNodes = $xpath->query('//article/front/article-meta/contrib-group/contrib/email');
            foreach ($authorEmailNodes as $node) {
                $node->parentNode->removeChild($node);
            }
        }
    }

    /**
     * Determine whether a submission file is a good candidate for JATS XML.
     */
    protected function isCandidateFile(SubmissionFile $submissionFile): bool
    {
        $fileService = app()->get('file');
        $filepath = $fileService->get($submissionFile->getData('fileId'))->path;
        $mimeType = $fileService->fs->mimeType($filepath);

        // The file type isn't XML.
        if (!in_array($mimeType, ['application/xml', 'text/xml'])) {
            return false;
        }

        static $genres = [];
        $genreDao = DAORegistry::getDAO('GenreDAO'); /** @var \PKP\submission\GenreDAO $genreDao */
        $genreId = $submissionFile->getData('genreId');
        if (!isset($genres[$genreId])) {
            $genres[$genreId] = $genreDao->getById($genreId);
        }
        assert($genres[$genreId]);
        $genre = $genres[$genreId]; /** @var \PKP\submission\Genre $genre */

        // The genre doesn't look like a main submission document.
        if ($genre->getCategory() != Genre::GENRE_CATEGORY_DOCUMENT) {
            return false;
        }
        if ($genre->getDependent()) {
            return false;
        }
        if ($genre->getSupplementary()) {
            return false;
        }

        // Ensure that the file looks like a JATS document.
        $doc = new DOMDocument();
        $doc->loadXML($fileService->fs->read($filepath));
        $xpath = new DOMXPath($doc);
        $articleMetaNode = $xpath->query('//article/front/article-meta')->item(0);
        if (!$articleMetaNode) {
            return false;
        }

        return true;
    }
}
